#include "pch.h"
#include "Dumper.h"
#include <iostream>
#include <iomanip>
#include <fstream>
#include <psapi.h>
#include <ShlObj.h>
#include <sstream>

Dumper::Dumper()
    : m_hGameModule(nullptr), m_gameBase(0), m_gameSize(0) {
    Log("Dumper initialized");
}

Dumper::~Dumper() {
    Log("Dumper shutdown");
}

bool Dumper::Initialize() {
    m_hGameModule = GetModuleHandleA("GameAssembly.dll");
    if (!m_hGameModule) {
        Log("Failed to find GameAssembly.dll");
        return false;
    }

    MODULEINFO modInfo;
    if (!GetModuleInformation(GetCurrentProcess(), m_hGameModule, &modInfo, sizeof(modInfo))) {
        Log("Failed to get module information");
        return false;
    }

    m_gameBase = reinterpret_cast<uintptr_t>(m_hGameModule);
    m_gameSize = modInfo.SizeOfImage;
    Log("Module base: " + ToHexString(m_gameBase) + ", size: " + std::to_string(m_gameSize) + " bytes");

    return true;
}

void Dumper::DumpAll() {
    Log("Starting offset dump...");

    m_offsets.clear();

    FindCoreOffsets();

    if (IsInGame()) {
        FindGameplayOffsets();
    }

    SaveOffsetsToFile("rust_offsets.txt");

    Log("Dump completed. Found " + std::to_string(m_offsets.size()) + " offsets.");
}

bool Dumper::IsInGame() {
    std::vector<uint8_t> gameStatePattern = { 0x80, 0x3D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x74, 0x00 };
    uintptr_t gameStatePtr = FindPattern(gameStatePattern, "xx?????x?");

    if (gameStatePtr) {
        return *reinterpret_cast<bool*>(gameStatePtr + 7);
    }
    return false;
}

void Dumper::FindCoreOffsets() {
    // GameAssembly base (always available)
    AddOffset("GameAssembly", m_gameBase);

    // BaseNetworkable (works in menu)
    const uintptr_t manualBaseNetworkable = 0x7FFE91728A88; // Your found address
    if (IsValidGameAddress(manualBaseNetworkable)) {
        AddOffset("BaseNetworkable", manualBaseNetworkable);
        Log("Using manual BaseNetworkable address");
    }
    else {
        Log("Invalid BaseNetworkable address!");
    }

    // CameraManager (works in menu)
    std::vector<uint8_t> cameraPattern = { 0x48, 0x8B, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8B, 0x01, 0xFF, 0x90 };
    uintptr_t cameraPtr = FindPattern(cameraPattern, "xxx????xxxxx");

    if (cameraPtr) {
        uintptr_t cameraBase = ResolveRelativeAddress(cameraPtr, 3, 7);
        AddOffset("CameraManager", cameraBase);
    }
}

void Dumper::FindGameplayOffsets() {
    // PlayerBase (your requested offset)
    std::vector<uint8_t> playerBasePattern = {
        0x48, 0x8B, 0x05, 0x00, 0x00, 0x00, 0x00, // mov rax,[PlayerBase]
        0x48, 0x85, 0xC0,                         // test rax,rax
        0x74, 0x0C                                // je short
    };
    uintptr_t playerBasePtr = FindPattern(playerBasePattern, "xxx????xxxxx");

    if (playerBasePtr) {
        uintptr_t playerBase = ResolveRelativeAddress(playerBasePtr, 3, 7);
        AddOffset("PlayerBase", playerBase);
    }
    else {
        const uintptr_t manualPlayerBase = 0x7FFE91A4B220; // Replace with your address
        if (IsValidGameAddress(manualPlayerBase)) {
            AddOffset("PlayerBase", manualPlayerBase);
        }
    }

    // PlayerList (your found address)
    const uintptr_t manualPlayerList = 0x7FFE9146DD88;
    if (IsValidGameAddress(manualPlayerList)) {
        AddOffset("PlayerList", manualPlayerList);
    }

    // LocalPlayer
    std::vector<uint8_t> playerPattern = { 0x48, 0x8B, 0x05, 0x00, 0x00, 0x00, 0x00, 0x48, 0x85, 0xC0, 0x74, 0x0D };
    uintptr_t playerPtr = FindPattern(playerPattern, "xxx????xxxxx");

    if (playerPtr) {
        uintptr_t playerBase = ResolveRelativeAddress(playerPtr, 3, 7);
        AddOffset("LocalPlayer", playerBase);
    }
}

void Dumper::SaveOffsetsToFile(const std::string& filename) {
    char desktopPath[MAX_PATH];
    if (!SHGetSpecialFolderPathA(NULL, desktopPath, CSIDL_DESKTOP, FALSE)) {
        Log("Failed to get desktop path!");
        return;
    }

    std::string fullPath = std::string(desktopPath) + "\\" + filename;
    std::ofstream file(fullPath);

    if (!file.is_open()) {
        Log("Failed to create file: " + fullPath);
        return;
    }

    file << "// Rust Offsets Dump\n";
    file << "// Generated by RustOffsetDumper\n\n";
    file << "#pragma once\n#include <cstdint>\n\n";
    file << "namespace Offsets {\n";

    for (const auto& offset_pair : m_offsets) {
        file << "    constexpr uintptr_t " << offset_pair.first << " = 0x"
            << ToHexString(offset_pair.second) << ";\n";
    }

    file << "}\n";
    file.close();

    Log("Offsets saved to: " + fullPath);
}

uintptr_t Dumper::FindPattern(const std::vector<uint8_t>& pattern, const std::string& mask) {
    if (pattern.size() != mask.length()) {
        Log("Pattern and mask size mismatch!");
        return 0;
    }

    uint8_t* scanBytes = reinterpret_cast<uint8_t*>(m_gameBase);
    const size_t patternLength = mask.length();

    for (size_t i = 0; i < m_gameSize - patternLength; i++) {
        bool found = true;
        for (size_t j = 0; j < patternLength; j++) {
            if (mask[j] != '?' && scanBytes[i + j] != pattern[j]) {
                found = false;
                break;
            }
        }
        if (found) {
            return m_gameBase + i;
        }
    }

    Log("Pattern not found for mask: " + mask);
    return 0;
}

uintptr_t Dumper::ResolveRelativeAddress(uintptr_t instructionPtr, int offset, int instructionSize) {
    return instructionPtr + *reinterpret_cast<int*>(instructionPtr + offset) + instructionSize;
}

bool Dumper::IsValidGameAddress(uintptr_t address) {
    return address >= m_gameBase && address <= (m_gameBase + m_gameSize);
}

std::string Dumper::ToHexString(uintptr_t value) {
    std::stringstream ss;
    ss << std::hex << std::uppercase << value;
    return ss.str();
}

void Dumper::AddOffset(const std::string& name, uintptr_t offset) {
    m_offsets.emplace_back(name, offset);
    Log("Found " + name + " = " + ToHexString(offset));
}

void Dumper::Log(const std::string& message) {
    std::cout << "[Dumper] " << message << std::endl;
}